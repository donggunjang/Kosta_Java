** 추상 클래스와 추상 메소드에 대하여 설명 하시오.
미래에 만들어질 후손들이 가져야 할 공통적인 속성과 동작을 뽑아서 
일반화(부모클래스)할때 반드시 자식 클래스가 가져야할 메소드인데
바디를 구체화 할 수 없는 메소드는 추상 메소드로 만든다.
메소드 이름 앞에 abstract 을 붙여 추상메서드 임을 표시
추상 메서드를 1개라도 가지고 있는 클래스를 추상 클래스라고 한다.

--------------------------------------------------------------------------
1.추상클래스와 추상메소드
==> 미래에 만들어질 자식클래스들이 가져야할 공톡적인 속성과 동작을 뽑아
	일반화 할 때에(부모클래스를 만들때) 어떠한 메소드가 반드시 자식클래스에
	필요하고 자식클래스들에게 맞도록 재정의해야 하는 메소드가 있을때에
	부모클래스를 만드는 시점에서는 그 메소드의 body를 구체화 할 수 없을때
	메소드 선언만 하게 된다. 이와 같이 메소드 body가 없고 메소드 선언부만
	있는 메소드를 "추상메소드"라고 하고
	메소드 앞에 abstract 키워드를 붙여 준다.
	
	이와 같이 어떠한 클래스가 추상메소드를 하나라도 갖고 있다면
	그 클래스 자신이 추상클래스가 되어야 하며 클래스 앞에 abstract 키워드를
	붙여야 한다.
	
	따라서, 어떠한 클래스가 추상클래스로 부터 상속받았다면
	반드시 그 추상클래스 안에 있는 모든 추상메소드를 오버라이딩 해야 한다.
	
	일반적으로
	상속과계에 있을 때 
	자식클래스는 부모의 메소드가 마음에 들면 그대로 사용하고
	자신에게 맞지 않으면 선택적으로 메소드를 재정의(오버라이딩) 할 수 있다.
	그런데 만약
	자식클래스 들에게 어떠한 메소드를 반드시(필수적으로) 오버라이딩 하도록 하고자 한다면
	그 메소드를 추상메소드로 만들어 준다.
	
	또한, 추상클래스는 body가 구체화 되지 않는 메소드를 갖고 있기 때문에 
	추상클래스의 객체는 생성할 수 없다.
	
	그러나 추상클래스의 참조변수가
	추상메소드를 오버라이딩 한 자식 클래스의 객체는 생성할 수 있다.(참조 할 수 있다.) 
-------------------------------------------------------------------
	부모의 참조 변수가 자식의 객체를 생성할 수 있지만
	자식에서 새로 추가된 메소드를 호출할 순 없다.
	호출하려면 자식 클래스로 형변환 해야한다.
	
상속관계에 있을때
부모의 참조변수가 자식클래스의 객체를 참조할 수 있다.
하지만 자식클래스에 새로 추가된 메소드를 바로 호출 할 수는 없고
자식 클래스로 형변환 한 후에 호출할 수 있다.

class A{
	...
}

class B extends A{
	...
	public void pro(){
	}
}

A ob = new B();
위의 코드에서 부모의 참조변수가 자식 클래스인 B의 객체를 참조할 수 있다.
하지만 다음과 같이 자식에서 부모에는 없는 새로 추가된 메소드 pro를 바로 호출 할 수 없다.
ob.pro();

호출 하려면 자식클래스로 형변환 후에 메소드를 호출 해야한다.

((B).ob).pro()
-------------------------------------------------------------------
class A{
	...
}

class C extends A{
	...
	public void hello{
	}
}

class B extends A{
	...
	public void pro(){
	}
}

A []data = new A[];
....

배열의 자료형이 A이기 때문에 
배열에는 A의 후손인 B,C의 자료형을 모두 담을 수 있다.
배열의 요소만큼 반복실행 하여
배열의 요소가 B의 자료형이라면 B클래스에 추가된 pro를 동작시키고
그렇지 않으면 C클래스에 추가된 hello를 동작시켜야 한다면
해당 클래스의 객체인지 물어봐서 해당 클래스로 형변화 해야 한다.
이때 해당클래스의 객체인지 판별하기 위한 연산자가 instanceof 이다.

for(A ob:data){
	if(ob instanceof B){
		((B)ob).pro();
	}else{
		((C)ob).hello;
	}
}
-------------------------------------------------------------------

2차원 도형도 담고, 3차원 도형도 담기 위해
data배열의 자료형을 2차원도형과 3차원도형 클래스의 부모클래스인 Shape으로 만들었다.
배열의 요소를 꺼내 오면 Shape이다.
만약, 그것이 2차원도형 클래스라면 2차원 도형 클래스로 변환한 후 면적을 계산 시키는 메소드를 호출하고
3차원 도형이라면 3차원 도형클래스로 변환한 후에 부피를 계산시키는 메소드를 호출할 수 있다

for(int j=0; j<n; j++) {
	Shape s = data[j];
	if (s instanceof TwoDimShape) {
		((TwoDimShape)s).calcArea();
	}else {
		((ThreeDimShape)s).calcVolume();
	}
	System.out.println(s);
}

----------------------------------------------------------------------
instanceof
==> 상속관계에 있을때 부모의 참조변수가
	자식의 객체를 참조할 수 있다.
	많은 양의 데이터를 처리 하기 위해 배열을 이용하는데
	부모의 참조자료형으로 배열을 만들면
	많은 종류의 자식 클래스의 객체를 담을 수 있다.
	
	그러나
	해당 자식클래스에서 추가된 메소드를 바로 호출 할 수는 없어서
	해당 자식클래스로 형변화해야 하는데
	이때 어떤 자식클래스인지 판별할 때 instanceof를 사용한다.
	
-----------------------------------------------------------------------
