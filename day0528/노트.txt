public class StringAndStringBuffer {
	public static void pro(String data) {
		System.out.println(data+"를 처리 했습니다.");
	}
	
	public static void main(String[] args) {
		StringBuffer cmd = new StringBuffer();
		cmd.append("insert ");
		cmd.append("into ");
		cmd.append("member ");
		cmd.append("values (");
		cmd.append("tiger");
		cmd.append(",'010-1234-5678'");
		cmd.append("'서울')");
		System.out.println(cmd);
		pro(cmd.toString());	//StirngBuffer를 String으로 변환 해야 한다.
	}
	
}

위의 코드는 변하는 문자열 처리를 위하여
StringBuffer를 사용한 예를 보여 주고 있다

그러나 대부분의 문자열을 매개변수로 하는 메소드 들은
String을 매개변수로 하도록 되어 있으므로
StringBuffer를 String으로 변환 해주어야 한다.

------------------------------------------------------------------------------------------
<< 예외처리 >>
프로그램 실행중에 발생할 수 있는 예기치 않는 상황에 대한 처리를 말한다.
몇가지 예기치 않는 상황에 대한 예를 들어보면
배열의 크기가 n이면 사용할 수 있는 index는 0~n-1 까지 이다.
그 범위가 아닌 인덱스에 접근하는 상황.

또, 어떤 수를 0으로 나누는 상황
문장자체에 문법적 오류는 없으나 실행중 사용자의 입력값이 바람직 하지 않아
발생할 수 있는 예기치 않는 상황

C:\javaStudy\day0528>java Calc
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0
        at Calc.main(Calc.java:6)

C:\javaStudy\day0528>java Calc tk dl
Exception in thread "main" java.lang.NumberFormatException: For input string: "tk"
        at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)
        at java.base/java.lang.Integer.parseInt(Integer.java:588)
        at java.base/java.lang.Integer.parseInt(Integer.java:685)
        at Calc.main(Calc.java:6)

만약 프로그램 실행시에 다음과 같이 두개의 정수를 전달하지 않거나
부적합한 값을 전달하게 되면 


자바는 대부분 대한 일반적인 예외처리에 대한 클래스가 만들어져 있다.
예외처리가 되어야 할 상황이 되면 예외처리 객체가 자동으로 생성이 된다.

예를 들어
배열의 익데스 범위를 넘으면
ArrayIndexOutOfBoundsExeption 객체가 자동으로 생성되고

숫자형식에 맞지 않으면
NumberFormatException 객체가 자동으로 생성된다.

--------------------------------------------------------------------------------------
<< 예외처리 방법 >>

try{
	예외가 발생할 만한 문장(들)
}catch(예외클래스명 변수명){
	예외가 발생이 되었을때 처리할 명령어(들)
}catch(예외클래스명 변수명){
	예외가 발생이 되었을때 처리할 명령어(들)
}

-------------------------------------------------------------------------------------
메소드 안에서 예외가 발생하는 경우
1) 메소드 자신이 직접 try~catch로 처리.
2) 메소드 호출하는 쪽으로 예외처리를 맡긴다 ==> throws


class ExceptionTest03
{
	public static void calcDiv(int a, int b) throws ArithmeticException {
		int r = a/b;
		System.out.println("나누기 결과:"+r);
	}

	public static void main(String[] args){ 
		try{
			calcDiv(4,2);
			calcDiv(4,0); //예외발생:/ by zero
		}catch(ArithmeticException e){
			System.out.println("예외발생:"+e.getMessage());
			//e.getMessage()
		}
	}
}

---------------------------------------------------------------------------------------------

예외처리
==> 프로그램 코드에는 문제가 없고 잘 컴파일이 되고 
	실행도 되지만 프로그램 실행중에
	사용자의 부주의 등으로 인하여 발생할 수 있는
	예기치 않는 상황을 "예외"라고 하며
	그것을 처리하는 것을 "예외처리"라고 한다.
	
예외가 발생할 만한 메소드에서 예외처리하는 방법
1) 메소드 자신이 try~catch로 예외처리 한다.
	try{
		예외가 발생할 만한 명령어
	}catch(예외클래스명){
		예외가 발생 되었을때 처리할 명령어 
	}
2) 메소드 호출하는 쪽으로 예외처리를 전달한다.
	public 리턴타입 메소드명([매개변수]) throws 예외클래스명,예외클래스명...{
	
	}
	
-----------------------------------------------------------------------------------------------
하나의 try에 여러개의 catch가 올 수 있따.
(단, catch절의 예외클래스가 상속관계에 있을때 
자식의 예외클래스가 먼저 와야 한다.)

try{

}catch(예외클래스명 변수명){

}catch(예외클래스명 변수명){

}


-----------------------------------------------------------------------------------------------
finally
	예외가 발생하면 문제가 발생하기 때문에 해당 catch절만 수행하고
	try문의 그 이후 명령은 동작하지 않는다
	만약에 예외가 발생하거나 정상동작 하거나
	반든시 수행 시키고자 하는 명령어(들)을 써준다.
	
-----------------------------------------------------------------------------------------------
try{

}catch(예외클래스명 변수명){

}catch(예외클래스명 변수명){

}finally{

}
-----------------------------------------------------------------------------------------------
** 예외처리에 대하여
예외 처리란 컴파일도 잘되고 실행도 잘 되지만
예기치 못한 상황이 일어 났을때 나는 문제들을 미리 정의 하여 처리하는 것
자바에서는 이러한 예외처리클래스들을 만들어 뒀다
그리고 
예외처리는
try~catch문을 사용한다.

**throws
throws는 메소드 뒤에 사용하고 
메소드 안에서 예외가 났을때 예외처리를 메소드 호출하는 곳에 넘겨주는 것이다.

**finally
예외가 났을때 try문이 다시 실행되지 않고 끝나 버리는데 
예외가 발생하던 안하던 반드시 동작하는 명령들을 적는다
-----------------------------------------------------------------------------------------------

RuntimeException
==> RuntimeException 후손들은
	특별히 예외처리를 하지 않아도 자바가
	예외처리를 해준다.
	
==> 그러나 RuntimeException 후손이 아닌 예외들은
	사용자가 반드시 예외처리를 해줘야 한다.
	
	java.io		에 있는 입출력 관련
	java.net	에 있는 네트워크 관련
	java.sql	에 있는 데이터베이스 관련
	
	위에 패키지들에 있는
	대부분의 클래스의 생성자와 메소드 들은
	예외를 가지고 있으며 RuntimeException의 후손이 아니다
	그래서 반드시 예외처리를 해야 한다.

-----------------------------------------------------------------------------------------------
<< 사용자 정의 예외 >>
자바는 대부분의 일반적인 예외에 대하여 
이미 클래스로 만들어져 있고, 그러한 상황이 되면 자동으로 예외 객체를 생성해 준다.

그런데 만약
내가 만들고 있는 시스템에서만
특별한 상황이 되면 "예외"로 만들고자 한다면
"사용자 정의 예외"를 만들 수 있고
그러한 상황이 도어도 자바는 예외인줄 모르기 때문에
직접 예외 객체를 생성해야 한다.

그때 사용하는 명령이 throw이다.
throw new 사용자정의예외();
라고 하여 사용자정의예외 객체를 생성할 수 있다.

그냥 출력문으로 메세지를 출력하면 되는데
왜 굳이 "사용자정의예외"를 만들어요?
==> 맞아요. 그냥 출력문을 써도 됩니다.
==> 우리가 만들고자 하는 시스템에서 사용자의 요청에 따라 발생할 수 있는 문제 
	상황을 미리 만들어 놓고 분명하게 하는 것이 목적이기 때문에 "사용자정의예외"를 만든다  

-----------------------------------------------------------------------------------------------
